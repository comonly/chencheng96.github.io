






<!doctype html>
<html>
<head>
<title>数据库连接池补充--Tomcat 的 JDBC 连接池_comonly.cn</title>
<meta name="keywords" content="数据库连接池补充--Tomcat 的 JDBC 连接池" />
<meta name="description" content="简介


	JDBC 连接池&nbsp;org.apache.tomcat.jdbc.pool&nbsp;是&nbsp;Apache Commons DBCP&nbsp;连接池的一种替换或备选方案。


	那究竟为何需要一个新的连接池？


	原因如下：


	
		Commons DBCP 1.x 是单线程。为了线程安全，在对象分配或对象返回的短期内，Commons 锁定了全部池。但注意这并不适用于 Commons DBCP 2.x。
	
	
		Commons DBCP" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="/css/css_yangqingqing.css" rel="stylesheet">
</head>
<body>
<div class="box">
 <div class="blank"></div>
 <div class="infosbox">
    <div class="newsview">
      <h3 class="news_title">数据库连接池补充--Tomcat 的 JDBC 连接池</h3>
      <div class="bloginfo">
        <ul>
          <li class="author">平心</li>
          <li class="lmname"><a href="https://www.cnblogs.com/pingxin/p/p00063.html" target="_blank">https://www.cnblogs.com/pingxin/p/p00063.html</a></li>
          <li class="timer">2021-08-28</li>
          	
         
          
          <!-- origin -->
		  <li class="view">
 

	数据库
 	  	
		  </li>		  
		  <li class="view">公开</li>

 
          <!-- 
          <li class="view">4567已阅读</li>
          <li class="like">8888888</li>
           -->
        </ul>
      </div>
      
      
        <div class="news_about"><strong>简介</strong>简介


	JDBC 连接池&nbsp;org.apache.tomcat.jdbc.pool&nbsp;是&nbsp;Apache Commons DBCP&nbsp;连接池的一种替换或备选方案。


	那究竟为何需要一个新的连接池？


	原因如下：


	
		Commons DBCP 1.x 是单线程。为了线程安全，在对象分配或对象返回的短期内，Commons 锁定了全部池。但注意这并不适用于 Commons DBCP 2.x。
	
	
		Commons DBCP</div>
      
      <!-- <div class="news_con"> -->
      <div class="realContent_kindeditor"> <h2 id="e05dce83e5129785b9f316978a14b896" style="font-size:21px;font-family:&quot;">
	简介
</h2>
<p style="font-family:&quot;font-size:14px;">
	JDBC 连接池&nbsp;org.apache.tomcat.jdbc.pool&nbsp;是&nbsp;<a href="http://commons.apache.org/proper/commons-dbcp/">Apache Commons DBCP</a>&nbsp;连接池的一种替换或备选方案。
</p>
<p style="font-family:&quot;font-size:14px;">
	那究竟为何需要一个新的连接池？
</p>
<p style="font-family:&quot;font-size:14px;">
	原因如下：
</p>
<ol style="font-family:&quot;font-size:14px;">
	<li>
		Commons DBCP 1.x 是单线程。为了线程安全，在对象分配或对象返回的短期内，Commons 锁定了全部池。但注意这并不适用于 Commons DBCP 2.x。
	</li>
	<li>
		Commons DBCP 1.x 可能会变得很慢。当逻辑 CPU 数目增长，或者试图借出或归还对象的并发线程增加时，性能就会受到影响。高并发系统受到的影响会更为显著。注意这并不适用于 Commons DBCP 2.x。
	</li>
	<li>
		Commons DBCP 拥有 60 多个类。tomcat-jdbc-pool 核心只有 8 个类。因此为了未来需求变更着想，肯定需要更少的改动。我们真正需要的只是连接池本身，其余的只是附属。
	</li>
	<li>
		Commons DBCP 使用静态接口，因此对于指定版本的 JRE，只能采用正确版本的 DBCP，否则就会出现&nbsp;NoSuchMethodException&nbsp;异常。
	</li>
	<li>
		当DBCP 可以用其他更简便的实现来替代时，实在不值得重写那 60 个类。
	</li>
	<li>
		Tomcat JDBC 连接池无需为库本身添加额外线程，就能获取异步获取连接。
	</li>
	<li>
		Tomcat JDBC 连接池是 Tomcat 的一个模块，依靠 Tomcat JULI 这个简化了的日志架构。
	</li>
	<li>
		使用&nbsp;javax.sql.PooledConnection&nbsp;接口获取底层连接。
	</li>
	<li>
		防止饥饿。如果池变空，线程将等待一个连接。当连接返回时，池就将唤醒正确的等待线程。大多数连接池只会一直维持饥饿状态。
	</li>
</ol>
<p style="font-family:&quot;font-size:14px;">
	Tomcat JDBC 连接池还具有一些其他连接池实现所没有的特点：
</p>
<ol style="font-family:&quot;font-size:14px;">
	<li>
		支持高并发环境与多核/CPU 系统。
	</li>
	<li>
		接口的动态实现。支持 java.sql 与 java.sql 接口（只要 JDBC 驱动），甚至在利用低版本的 JDK 来编译时。
	</li>
	<li>
		验证间隔时间。我们不必每次使用单个连接时都进行验证，可以在借出或归还连接时进行验证，只要不低于我们所设定的间隔时间就行。
	</li>
	<li>
		只执行一次查询。当与数据库建立起连接时，只执行一次的可配置查询。这项功能对会话设置非常有用，因为你可能会想在连接建立的整个时段内都保持会话。
	</li>
	<li>
		能够配置自定义拦截器。通过自定义拦截器来增强功能。可以使用拦截器来采集查询统计，缓存会话状态，重新连接之前失败的连接，重新查询，缓存查询结果，等等。由于可以使用大量的选项，所以这种自定义拦截器也是没有限制的，跟&nbsp;java.sql/javax.sql&nbsp;接口的 JDK 版本没有任何关系。
	</li>
	<li>
		高性能。后文将举例展示一些性能差异。
	</li>
	<li>
		极其简单。它的实现非常简单，代码行数与源文件都非常少，这都有赖于从一开始研发它时，就把简洁当做重中之重。对比一下 c3p0 ，它的源文件超过了 200 个（最近一次统计），而 Tomcat JDBC 核心只有 8 个文件，连接池本身则大约只有这个数目的一半，所以能够轻易地跟踪和修改可能出现的 Bug。
	</li>
	<li>
		异步连接获取。可将连接请求队列化，系统返回&nbsp;Future&lt;Connection&gt;。
	</li>
	<li>
		更好地处理空闲连接。不再简单粗暴地直接把空闲连接关闭，而是仍然把连接保留在池中，通过更为巧妙的算法控制空闲连接池的规模。
	</li>
	<li>
		可以控制连接应被废弃的时间：当池满了即废弃，或者指定一个池使用容差值，发生超时就进行废弃处理。
	</li>
	<li>
		通过查询或语句来重置废弃连接计时器。允许一个使用了很长时间的连接不因为超时而被废弃。这一点是通过使用&nbsp;ResetAbandonedTimer来实现的。
	</li>
	<li>
		经过指定时间后，关闭连接。与返回池的时间相类似。
	</li>
	<li>
		当连接要被释放时，获取 JMX 通知并记录所有日志。它类似于&nbsp;removeAbandonedTimeout，但却不需要采取任何行为，只需要报告信息即可。通过&nbsp;suspectTimeout&nbsp;属性来实现。
	</li>
	<li>
		可以通过&nbsp;java.sql.Driver、javax.sql.DataSource&nbsp;或&nbsp;javax.sql.XADataSource&nbsp;获取连接。通过&nbsp;dataSource&nbsp;与&nbsp;dataSourceJNDI&nbsp;属性实现这一点。
	</li>
	<li>
		支持 XA 连接。
	</li>
</ol>
<h2 id="ec09647dcef4ae3525cffab24748838d" style="font-size:21px;font-family:&quot;">
	使用方法
</h2>
<p style="font-family:&quot;font-size:14px;">
	对于熟悉 Commons DBCP 的人来说，转而使用 Tomcat 连接池是非常简单的事。从其他连接池转换过来也非常容易。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	1. 附加功能
</h3>
<p style="font-family:&quot;font-size:14px;">
	除了其他多数连接池能够提供的功能外，Tomcat 连接池还提供了一些附加功能：
</p>
<ul style="font-family:&quot;font-size:14px;">
	<li>
		initSQL&nbsp;当连接创建后，能够执行一个 SQL 语句（只执行一次）。
	</li>
	<li>
		validationInterval&nbsp;恰当地在连接上运行验证，同时又能避免太多频繁地执行验证。
	</li>
	<li>
		jdbcInterceptors&nbsp;灵活并且可插拔的拦截器，能够对池进行各种自定义，执行各种查询，处理结果集。下文将予以详述。
	</li>
	<li>
		fairQueue&nbsp;将 fair 标志设为 true，以达成线程公平性，或使用异步连接获取。
	</li>
</ul>
<h3 style="font-size:16px;font-family:&quot;">
	2. Apache Tomcat 容器内部
</h3>
<p style="font-family:&quot;font-size:14px;">
	在<a href="http://wiki.jikexueyuan.com/project/tomcat/%E3%80%8B%E9%9C%80%E8%A6%81%E6%9B%B4%E6%8D%A2%E4%B8%AD%E6%96%87%E9%A1%B5%E9%9D%A2http://tomcat.apache.org/tomcat-8.0-doc/jndi-datasource-examples-howto.html">Tomcat JDBC 文档</a>中，Tomcat 连接池被配置为一个资源。唯一的区别在于，你必须指定&nbsp;factory&nbsp;属性，并将其值设为&nbsp;org.apache.tomcat.jdbc.pool.DataSourceFactory。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	3. 独立性
</h3>
<p style="font-family:&quot;font-size:14px;">
	连接池只有一个从属文件，tomcat-juli.jar。要想在使用 bean 实例化的单一项目中使用池，实例化的 Bean 为org.apache.tomcat.jdbc.pool.DataSource。下文讲到将连接池配置为 JNDI 资源时会涉及到同一属性，也是用来将数据源配置成 bean 的。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	4. JMX
</h3>
<p style="font-family:&quot;font-size:14px;">
	连接池对象暴露了一个可以被注册的 MBean。为了让连接池对象创建 MBean，jmxEnabled&nbsp;标志必须设为 true。这并不是说连接池会注册到 MBean 服务器。在像 Tomcat 这样的容器中，Tomcat 本身注册就在 MBean 服务器上注册了 DataSource。org.apache.tomcat.jdbc.pool.DataSource&nbsp;对象会注册实际的连接池 MBean。如果你在容器外运行，可以将 DataSource 注册在任何你指定的对象名下，然后将这种注册传播到底层池。要想这样做，你必须调用&nbsp;mBeanServer.registerMBean(dataSource.getPool().getJmxPool(),objectname)。在调用之前，一定要保证通过调用&nbsp;dataSource.createPool()&nbsp;创建了池。
</p>
<h2 id="24d67862f87f439db7ca957aecb77cce" style="font-size:21px;font-family:&quot;">
	属性
</h2>
<p style="font-family:&quot;font-size:14px;">
	为了能够顺畅地在 Commons DBCP 与 Tomcat JDBC 连接池 之间转换，大多数属性名称及其含义都是相同的。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	1. JNDI 工厂与类型
</h3>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					factory
				</td>
				<td style="border:1px solid #C0C0C0;">
					必需的属性，其值应为&nbsp;org.apache.tomcat.jdbc.pool.DataSourceFactory
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					type
				</td>
				<td style="border:1px solid #C0C0C0;">
					类型应为&nbsp;javax.sql.DataSource&nbsp;或&nbsp;javax.sql.XADataSource。<br />
根据类型，将创建org.apache.tomcat.jdbc.pool.DataSource&nbsp;或&nbsp;org.apache.tomcat.jdbc.pool.XADataSource。
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	2. 系统属性
</h3>
<p style="font-family:&quot;font-size:14px;">
	系统属性作用于 JVM 范围，影响创建于 JVM 内的所有池。
</p>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					org.apache.tomcat.jdbc.pool.onlyAttemptCurrentClassLoader
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值，默认为&nbsp;false。控制动态类（如JDBC 驱动、拦截器、验证器）的加载。如果采用默认值，池会首先利用当前类加载器（比如已经加载池类的类加载器）加载类；如果类加载失败，则尝试利用线程上下文加载器加载。取值为&nbsp;true&nbsp;时，会向后兼容 Apache Tomcat 8.0.8 及更早版本，只会采用当前类加载器。如果未设置，则取默认值。
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	3. 常用属性
</h3>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					defaultAutoCommit
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）连接池所创建的连接默认自动提交状态。如果未设置，则默认采用 JDBC 驱动的缺省值（如果未设置，则不会调用&nbsp;setAutoCommit&nbsp;方法）。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					defaultReadOnly
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）连接池所创建的连接默认只读状态。如果未设置，将不会调用&nbsp;setReadOnly&nbsp;方法。（有些驱动并不支持只读模式，比如：informix）
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					defaultTransactionIsolation
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）连接池所创建的连接的默认事务隔离状态。取值范围为：（参考 javadoc）<br />
					<ul>
						<li>
							NONE
						</li>
						<li>
							READ_COMMITTED
						</li>
						<li>
							READ_UNCOMMITTED
						</li>
						<li>
							REPEATABLE_READ
						</li>
						<li>
							SERIALIZABLE
						</li>
					</ul>
<br />
如果未设置该值，则不会调用任何方法，默认为 JDBC 驱动。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					defaultCatalog
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）连接池所创建的连接的默认catalog。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					driverClassName
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）所要使用的 JDBC 驱动的完全限定的 Java 类名。该驱动必须能从与 tomcat-jdbc.jar 同样的类加载器访问
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					username
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）传入 JDBC 驱动以便建立连接的连接用户名。注意，DataSource.getConnection(username,password)方法默认不会使用传入该方法内的凭证，但会使用这里的配置信息。可参看&nbsp;alternateUsernameAllowed&nbsp;了解更多详情。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					password
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）传入 JDBC 驱动以便建立连接的连接密码。注意，DataSource.getConnection(username,password)方法默认不会使用传入该方法内的凭证，但会使用这里的配置信息。可参看&nbsp;alternateUsernameAllowed&nbsp;了解更多详情。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					maxActive
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整形值）池同时能分配的活跃连接的最大数目。默认为&nbsp;100。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					maxIdle
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）池始终都应保留的连接的最大数目。默认为&nbsp;maxActive:100。会周期性检查空闲连接（如果启用该功能），留滞时间超过&nbsp;minEvictableIdleTimeMillis&nbsp;的空闲连接将会被释放。（请参考&nbsp;testWhileIdle）
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					minIdle
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）池始终都应保留的连接的最小数目。如果验证查询失败，则连接池会缩减该值。默认值取自&nbsp;initialSize:10（请参考&nbsp;testWhileIdle）。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					initialSize
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）连接器启动时创建的初始连接数。默认为&nbsp;10。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					maxWait
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）在抛出异常之前，连接池等待（没有可用连接时）返回连接的最长时间，以毫秒计。默认为&nbsp;30000（30 秒）
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					testOnBorrow
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）默认值为&nbsp;false。从池中借出对象之前，是否对其进行验证。如果对象验证失败，将其从池中清除，再接着去借下一个。注意：为了让&nbsp;true&nbsp;值生效，validationQuery参数必须为非空字符串。为了实现更高效的验证，可以采用&nbsp;validationInterval。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					testOnReturn
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）默认值为&nbsp;false。将对象返回池之前，是否对齐进行验证。注意：为了让&nbsp;true&nbsp;值生效，validationQuery参数必须为非空字符串。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					testWhileIdle
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）是否通过空闲对象清除者（如果存在的话）验证对象。如果对象验证失败，则将其从池中清除。注意：为了让&nbsp;true值生效，validationQuery&nbsp;参数必须为非空字符串。该属性默认值为&nbsp;false，为了运行池的清除/测试线程，必须设置该值。（另请参阅&nbsp;timeBetweenEvictionRunsMillis）
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					validationQuery
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）在将池中连接返回给调用者之前，用于验证这些连接的 SQL 查询。如果指定该值，则该查询不必返回任何数据，只是不抛出&nbsp;SQLException&nbsp;异常。默认为&nbsp;null。实例值为：SELECT 1（MySQL）&nbsp;select 1 from dual（Oracle）&nbsp;SELECT 1（MySQL Server）。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					validationQueryTimeout
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）连接验证失败前的超时时间（以秒计）。通过在执行&nbsp;validationQuery&nbsp;的语句上调用&nbsp;java.sql.Statement.setQueryTimeout(seconds)&nbsp;来实现。池本身并不会让查询超时，完全是由 JDBC 来强制实现。若该值小于或等于 0，则禁用该功能。默认为&nbsp;-1。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					validatorClassName
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）实现&nbsp;org.apache.tomcat.jdbc.pool.Validator接口并提供了一个无参（可能是隐式的）构造函数的类名。如果指定该值，将通过该类来创建一个 Validator 实例来验证连接，代替任何验证查询。默认为&nbsp;null，范例值为：com.mycompany.project.SimpleValidator。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					timeBetweenEvictionRunsMillis
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）空闲连接验证/清除线程运行之间的休眠时间（以毫秒计）。不能低于 1 秒。该值决定了我们检查空闲连接、废弃连接的频率，以及验证空闲连接的频率。默认为&nbsp;5000（5 秒）
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					numTestsPerEvictionRun
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）Tomcat JDBC 连接池没有用到这个属性。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					minEvictableIdleTimeMillis
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）在被确定应被清除之前，对象在池中保持空闲状态的最短时间（以毫秒计）。默认为&nbsp;60000（60 秒）
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					accessToUnderlyingConnectionAllowed
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）没有用到的属性。可以在归入池内的连接上调用&nbsp;unwrap来访问。参阅&nbsp;javax.sql.DataSource&nbsp;接口的相关介绍，或者通过反射调用&nbsp;getConnection，或者将对象映射为&nbsp;javax.sql.PooledConnection。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					removeAbandoned
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）该值为标志（Flag）值，表示如果连接时间超出了&nbsp;removeAbandonedTimeout，则将清除废弃连接。如果该值被设置为&nbsp;true，则如果连接时间大于&nbsp;removeAbandonedTimeout，该连接会被认为是废弃连接，应予以清除。若应用关闭连接失败时，将该值设为&nbsp;true&nbsp;能够恢复该应用的数据库连接。另请参阅&nbsp;logAbandoned。默认值为&nbsp;false。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					removeAbandonedTimeout
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）在废弃连接（仍在使用）可以被清除之前的超时秒数。默认为&nbsp;60（60 秒）。应把该值设定为应用可能具有的运行时间最长的查询。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					logAbandoned
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）标志能够针对丢弃连接的应用代码，进行堆栈跟踪记录。由于生成堆栈跟踪，对废弃连接的日志记录会增加每一个借取连接的开销。默认为&nbsp;false
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					connectionProperties
				</td>
				<td style="border:1px solid #C0C0C0;">
					（字符串）在建立新连接时，发送给 JDBC 驱动的连接属性。字符串格式必须为：[propertyName=property;]*。注意：user 与 password 属性会显式传入，因此这里并不需要包括它们。默认为&nbsp;null。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					poolPreparedStatements
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）未使用的属性
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					maxOpenPreparedStatements
				</td>
				<td style="border:1px solid #C0C0C0;">
					（整型值）未使用的属性
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	4. Tomcat JDBC 增强属性
</h3>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					initSQL
				</td>
				<td style="border:1px solid #C0C0C0;">
					字符串值。当连接第一次创建时，运行的自定义查询。默认值为&nbsp;null。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					jdbcInterceptors
				</td>
				<td style="border:1px solid #C0C0C0;">
					字符串。继承自类&nbsp;org.apache.tomcat.jdbc.pool.JdbcInterceptor的子类类名列表，由分号分隔。关于格式及范例，可参见下文的配置 JDBC 拦截器。<br />
<br />
这些拦截器将会插入到&nbsp;java.sql.Connection&nbsp;对象的操作队列中。&nbsp;<br />
<br />
预定义的拦截器有：<br />
					<ul>
						<li>
							org.apache.tomcat.jdbc.pool.interceptor
						</li>
						<li>
							ConnectionState——记录自动提交、只读、catalog以及事务隔离级别等状态。
						</li>
						<li>
							org.apache.tomcat.jdbc.pool.interceptor
						</li>
						<li>
							StatementFinalizer——记录打开的语句，并当连接返回池后关闭它们。
						</li>
					</ul>
<br />
<br />
有关更多预定义拦截器的详尽描述，可参阅JDBC 拦截器
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					validationInterval
				</td>
				<td style="border:1px solid #C0C0C0;">
					长整型值。为避免过度验证而设定的频率时间值（以秒计）。最多以这种频率运行验证。如果连接应该进行验证，但却没能在此间隔时间内得到验证，则会重新对其进行验证。默认为&nbsp;30000（30 秒）。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					jmxEnabled
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。是否利用 JMX 注册连接池。默认为&nbsp;true。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					fairQueue
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。假如想用真正的 FIFO 方式公平对待&nbsp;getConnection&nbsp;调用，则取值为&nbsp;true。对空闲连接列表将采用&nbsp;org.apache.tomcat.jdbc.pool.FairBlockingQueue&nbsp;实现。默认值为&nbsp;true。如果想使用异步连接获取功能，则必须使用该标志。<br />
设置该标志可保证线程能够按照连接抵达顺序来接收连接。<br />
在性能测试时，锁及锁等待的实现方式有很大差异。当&nbsp;fairQueue=true&nbsp;时，根据所运行的操作系统，存在一个决策过程。假如系统运行在 Linux 操作系统（属性&nbsp;os.name = linux）上，为了禁止这个 Linux 专有行为，但仍想使用公平队列，那么只需在连接池类加载之前，将&nbsp;org.apache.tomcat.jdbc.pool.FairBlockingQueue.ignoreOS=true添加到系统属性上。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					abandonWhenPercentageFull
				</td>
				<td style="border:1px solid #C0C0C0;">
					整型值。除非使用中连接的数目超过&nbsp;abandonWhenPercentageFull中定义的百分比，否则不会关闭并报告已废弃的连接（因为超时）。取值范围为 0-100。默认值为 0，意味着只要达到&nbsp;removeAbandonedTimeout，就应关闭连接。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					maxAge
				</td>
				<td style="border:1px solid #C0C0C0;">
					长整型值。连接保持时间（以毫秒计）。当连接要返回池中时，连接池会检查是否达到&nbsp;now - time-when-connected &gt; maxAge&nbsp;的条件，如果条件达成，则关闭该连接，不再将其返回池中。默认值为&nbsp;0，意味着连接将保持开放状态，在将连接返回池中时，不会执行任何年龄检查。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					useEquals
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。如果想让&nbsp;ProxyConnection&nbsp;类使用&nbsp;String.equals，则将该值设为&nbsp;true；若想在对比方法名称时使用&nbsp;==，则应将其设为&nbsp;false。该属性不能用于任何已添加的拦截器中，因为那些拦截器都是分别配置的。默认值为&nbsp;true。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					suspectTimeout
				</td>
				<td style="border:1px solid #C0C0C0;">
					整型值。超时时间（以秒计）。默认值为&nbsp;0。<br />
类似于&nbsp;removeAbandonedTimeout，但不会把连接当做废弃连接从而有可能关闭连接。如果&nbsp;logAbandoned&nbsp;设为&nbsp;true，它只会记录下警告。如果该值小于或等于 0，则不会执行任何怀疑式检查。如果超时值大于 0，而连接还没有被废弃，或者废弃检查被禁用时，才会执行怀疑式检查。如果某个连接被怀疑到，则记录下 WARN 信息并发送一个 JMX 通知。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					rollbackOnReturn
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。如果&nbsp;autoCommit==false，那么当连接返回池中时，池会在连接上调用回滚方法，从而终止事务。默认值为&nbsp;false。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					commitOnReturn
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。如果&nbsp;autoCommit==false，那么当连接返回池中时，池会在连接上调用提交方法，从而完成事务；如果&nbsp;rollbackOnReturn==true，则忽略该属性。默认值为&nbsp;false。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					alternateUsernameAllowed
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。出于性能考虑，JDBC 连接池默认会忽略&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)">DataSource.getConnection(username,password)</a>调用，只返回之前池化的具有全局配置属性&nbsp;username&nbsp;和&nbsp;password的连接。<br />
<br />
但经过配置，连接池还可以允许使用不同的凭证来请求每一个连接。为了启用这项在<a href="http://docs.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String,%20java.lang.String)">DataSource.getConnection(username,password)</a>调用中描述的功能，只需将&nbsp;alternateUsernameAllowed&nbsp;设为&nbsp;true。<br />
如果你请求一个连接，凭证为 user 1/password 1，而连接之前使用的是 user 2/password 2 凭证，那么连接将被关闭，重新利用请求的凭证来开启。按照这种方式，池的容量始终以全局级别管理，而不是限于模式（schema）级别。<br />
默认值为&nbsp;false。<br />
该属性作为一个改进方案，被添加到了&nbsp;<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=50025">bug 50025</a>&nbsp;中。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					dataSource
				</td>
				<td style="border:1px solid #C0C0C0;">
					（javax.sql.DataSource）将数据源注入连接池，从而使池利用数据源来获取连接，而不是利用&nbsp;java.sql.Driver接口来建立连接。它非常适于使用数据源（而非连接字符串）来池化 XA 连接或者已建立的连接时。默认值为&nbsp;null。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					dataSourceJNDI
				</td>
				<td style="border:1px solid #C0C0C0;">
					字符串。在 JNDI 中查找的数据源的 JNDI 名称，随后将用于建立数据库连接。参看&nbsp;datasource&nbsp;属性的介绍。默认值为&nbsp;null。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					useDisposableConnectionFacade
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。如果希望在连接上放上一个门面对象，从而使连接在关闭后无法重用，则要将值设为&nbsp;true。这能防止线程继续引用一个已被关闭的连接，并继续在连接上查询。默认值为&nbsp;true。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					logValidationErrors
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。设为&nbsp;true&nbsp;时，能将验证阶段的错误记录到日志文件中，错误会被记录为 SEVERE。考虑到了向后兼容性，默认值为&nbsp;false。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					propagateInterruptState
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。传播已中断的线程（还没有清除中断状态）的中断状态。考虑到了向后兼容性，默认值为&nbsp;false。
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					ignoreExceptionOnPreLoad
				</td>
				<td style="border:1px solid #C0C0C0;">
					布尔值。在初始化池时，是否忽略连接创建错误。取值为&nbsp;true时表示忽略；设为&nbsp;false&nbsp;时，抛出异常，从而宣告池初始化失败。默认值为&nbsp;false。
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h2 id="66d3e5991ea5483e5479ccc849d7e340" style="font-size:21px;font-family:&quot;">
	高级用法
</h2>
<h3 style="font-size:16px;font-family:&quot;">
	1. JDBC 拦截器
</h3>
<p style="font-family:&quot;font-size:14px;">
	要想看看拦截器使用方法的具体范例，可以看看&nbsp;org.apache.tomcat.jdbc.pool.interceptor.ConnectionState。这个简单的拦截器缓存了三个属性：autoCommit、readOnly、transactionIsolation，为的是避免系统与数据库之间无用的往返。
</p>
<p style="font-family:&quot;font-size:14px;">
	当需求增加时，姜维连接池核心增加更多的拦截器。欢迎贡献你的才智！
</p>
<p style="font-family:&quot;font-size:14px;">
	拦截器当然并不局限于&nbsp;java.sql.Connection，当然也可以对方法调用的任何结果进行包装。你可以构建查询性能分析器，以便当查询运行时间超过预期时间时提供 JMX 通知。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	2. 配置 JDBC 拦截器
</h3>
<p style="font-family:&quot;font-size:14px;">
	JDBC 拦截器是通过&nbsp;jdbcInterceptor&nbsp;属性来配置的。该属性值包含一列由分号分隔的类名。如果这些类名非完全限定，就会在它们的前面加上&nbsp;org.apache.tomcat.jdbc.pool.interceptor.&nbsp;前缀。
</p>
<p style="font-family:&quot;font-size:14px;">
	范例：<br />
jdbcInterceptors="org.apache.tomcat.jdbc.pool.interceptor.ConnectionState; org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer"<br />
它实际上等同于：<br />
jdbcInterceptors="ConnectionState;StatementFinalizer"
</p>
<p style="font-family:&quot;font-size:14px;">
	拦截器也同样有属性。拦截器的属性指定在类名后的括号里，如果设置多个属性，则用逗号分隔开。
</p>
<p style="font-family:&quot;font-size:14px;">
	范例：
</p>
<p style="font-family:&quot;font-size:14px;">
	jdbcInterceptors="ConnectionState;StatementFinalizer(useEquals=true)"
</p>
<p style="font-family:&quot;font-size:14px;">
	系统会自动忽略属性名称、属性值以及类名前后多余的空格字符。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.JdbcInterceptor
</h3>
<p style="font-family:&quot;font-size:14px;">
	所有拦截器的抽象基类，无法实例化。
</p>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					useEquals
				</td>
				<td style="border:1px solid #C0C0C0;">
					（布尔值）如果希望&nbsp;ProxyConnection&nbsp;类使用&nbsp;String.equals，则设为 true；当希望在对比方法名时使用&nbsp;==，则设为&nbsp;false。默认为&nbsp;true。
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.ConnectionState
</h3>
<p style="font-family:&quot;font-size:14px;">
	它能为下列属性缓存连接：autoCommit、readOnly、transactionIsolation&nbsp;及&nbsp;catalog。这是一种性能增强功能，当利用已设定的值来调用 getter 与 setter 时，它能够避免往返数据库。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer
</h3>
<p style="font-family:&quot;font-size:14px;">
	跟踪所有使用&nbsp;createStatement、prepareStatement&nbsp;或&nbsp;prepareCall&nbsp;的语句，当连接返回池后，关闭这些语句。
</p>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					trace
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的布尔值）对未关闭语句进行跟踪。当启用跟踪且连接被关闭时，如果相关语句没有关闭，则拦截器会记录所有的堆栈跟踪。默认值为&nbsp;false。
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.StatementCache
</h3>
<p style="font-family:&quot;font-size:14px;">
	缓存连接中的&nbsp;PreparedStatement&nbsp;或&nbsp;CallableStatement&nbsp;实例。
</p>
<p style="font-family:&quot;font-size:14px;">
	它会针对每个连接对这些语句进行缓存，然后计算池中所有连接的整体缓存数，如果缓存数超过了限制&nbsp;max，就不再对随后的语句进行缓存，而是直接关闭它们。
</p>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					prepared
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的布尔值）对使用&nbsp;prepareStatement&nbsp;调用创建的&nbsp;PreparedStatement实例进行缓存。默认为&nbsp;true
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					callable
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的布尔值）对使用&nbsp;prepareCall&nbsp;调用创建的&nbsp;CallableStatement实例进行缓存。默认为&nbsp;false
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					max
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的整型值）连接池中的缓存语句的数量限制。默认为&nbsp;50
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor
</h3>
<p style="font-family:&quot;font-size:14px;">
	请参看&nbsp;<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=48392">48392</a>。拦截器会包装语句和结果集，从而防止对使用了&nbsp;ResultSet.getStatement().getConnection()&nbsp;和&nbsp;Statement.getConnection()&nbsp;方法的实际连接进行访问。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.QueryTimeoutInterceptor
</h3>
<p style="font-family:&quot;font-size:14px;">
	当新语句创建时，自动调用&nbsp;java.sql.Statement.setQueryTimeout(seconds)。池本身并不会让查询超时，完全是依靠 JDBC 驱动来强制查询超时。
</p>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					queryTimeout
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的整型值）查询超时的毫秒数。默认为&nbsp;1000&nbsp;毫秒。
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport
</h3>
<p style="font-family:&quot;font-size:14px;">
	当查询超过失败容差值时，记录查询性能并发布日志项目。使用的日志级别为&nbsp;WARN。
</p>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					threshold
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的整型值）查询应超时多少毫秒才发布日志警告。默认为&nbsp;1000&nbsp;毫秒
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					maxQueries
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的整型值）为保留内存空间，所能记录的最大查询数量。默认为&nbsp;1000
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					logSlow
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的布尔值）如果想记录较慢的查询，设为&nbsp;true。默认为&nbsp;true
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					logFailed
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的布尔值）如果想记录失败查询，设为&nbsp;true。默认为&nbsp;true
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx
</h3>
<p style="font-family:&quot;font-size:14px;">
	这是对&nbsp;SlowQueryReport&nbsp;的扩展，除了发布日志项目外，它还发布 JMX 通知，以便监视工具作出相关反应。该类从其父类继承了所有属性。它使用了 Tomcat 的 JMX 引擎，所以在 Tomcat 容器外部是无效的。使用该类时，默认情况下，是通过&nbsp;ConnectionPool&nbsp;MBean 来发送 JMX 通知。如果&nbsp;notifyPool=false，则&nbsp;SlowQueryReportJmx&nbsp;也可以注册一个 MBean。
</p>
<div class="table-wrapper" style="margin:0px;padding:0px;font-family:&quot;font-size:14px;">
	<table style="margin:0px;padding:0px;">
		<tbody>
			<tr>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					属性
				</th>
				<th style="background-color:#FAFAFA;border:1px solid #C0C0C0;">
					描述
				</th>
			</tr>
		</tbody>
		<tbody>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					notifyPool
				</td>
				<td style="border:1px solid #C0C0C0;">
					（以字符串形式表示的布尔值）如果希望用&nbsp;SlowQueryReportJmx&nbsp;MBean 发送 JMX 通知，则设为&nbsp;false。默认为&nbsp;true
				</td>
			</tr>
			<tr>
				<td style="border:1px solid #C0C0C0;">
					objectName
				</td>
				<td style="border:1px solid #C0C0C0;">
					字符串。定义一个有效的&nbsp;javax.management.ObjectName&nbsp;字符串，用于将这一对象注册到平台所用的 mbean 服务器上。默认值为&nbsp;null。可以使用&nbsp;tomcat.jdbc:type=org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx,name=the-name-of-the-pool&nbsp;来注册对象。
				</td>
			</tr>
		</tbody>
	</table>
</div>
<h3 style="font-size:16px;font-family:&quot;">
	org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer
</h3>
<p style="font-family:&quot;font-size:14px;">
	当连接签出池中后，废弃计时器即开始计时。这意味着如果超时为 30 秒，而你使用连接运行了 10 个 10秒的查询，那么它就会被标为废弃，并可能依靠&nbsp;abandonWhenPercentageFull&nbsp;属性重新声明。每次成功地在连接上执行操作或执行查询时，该拦截器就会重设签出计时器。
</p>
<h2 id="00e5c2ce9847b754aacbbbfcab3ec5bb" style="font-size:21px;font-family:&quot;">
	代码范例
</h2>
<p style="font-family:&quot;font-size:14px;">
	其他 JDBC 用途的 Tomcat 配置范例可以参考 相关的&nbsp;<a href="http://tomcat.apache.org/tomcat-8.0-doc/jndi-datasource-examples-howto.html">Tomcat 文档</a>。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	简单的 Java
</h3>
<p style="font-family:&quot;font-size:14px;">
	下面这个简单的范例展示了如何创建并使用数据源：
</p>
<pre><span class="hljs-keyword" style="color:#0000FF;">import</span> java.sql.Connection; <span class="hljs-keyword" style="color:#0000FF;">import</span> java.sql.ResultSet; <span class="hljs-keyword" style="color:#0000FF;">import</span> java.sql.Statement; <span class="hljs-keyword" style="color:#0000FF;">import</span> org.apache.tomcat.jdbc.pool.DataSource; <span class="hljs-keyword" style="color:#0000FF;">import</span> org.apache.tomcat.jdbc.pool.PoolProperties; <span class="hljs-keyword" style="color:#0000FF;">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:#0000FF;">class</span> <span class="hljs-title" style="color:#A31515;">SimplePOJOExample</span> </span>{ <span class="hljs-function"><span class="hljs-keyword" style="color:#0000FF;">public</span> <span class="hljs-keyword" style="color:#0000FF;">static</span> <span class="hljs-keyword" style="color:#0000FF;">void</span> <span class="hljs-title" style="color:#A31515;">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword" style="color:#0000FF;">throws</span> Exception </span>{
          PoolProperties p = <span class="hljs-keyword" style="color:#0000FF;">new</span> PoolProperties();
          p.setUrl(<span class="hljs-string" style="color:#A31515;">"jdbc:mysql://localhost:3306/mysql"</span>);
          p.setDriverClassName(<span class="hljs-string" style="color:#A31515;">"com.mysql.jdbc.Driver"</span>);
          p.setUsername(<span class="hljs-string" style="color:#A31515;">"root"</span>);
          p.setPassword(<span class="hljs-string" style="color:#A31515;">"password"</span>);
          p.setJmxEnabled(<span class="hljs-keyword" style="color:#0000FF;">true</span>);
          p.setTestWhileIdle(<span class="hljs-keyword" style="color:#0000FF;">false</span>);
          p.setTestOnBorrow(<span class="hljs-keyword" style="color:#0000FF;">true</span>);
          p.setValidationQuery(<span class="hljs-string" style="color:#A31515;">"SELECT 1"</span>);
          p.setTestOnReturn(<span class="hljs-keyword" style="color:#0000FF;">false</span>);
          p.setValidationInterval(<span class="hljs-number">30000</span>);
          p.setTimeBetweenEvictionRunsMillis(<span class="hljs-number">30000</span>);
          p.setMaxActive(<span class="hljs-number">100</span>);
          p.setInitialSize(<span class="hljs-number">10</span>);
          p.setMaxWait(<span class="hljs-number">10000</span>);
          p.setRemoveAbandonedTimeout(<span class="hljs-number">60</span>);
          p.setMinEvictableIdleTimeMillis(<span class="hljs-number">30000</span>);
          p.setMinIdle(<span class="hljs-number">10</span>);
          p.setLogAbandoned(<span class="hljs-keyword" style="color:#0000FF;">true</span>);
          p.setRemoveAbandoned(<span class="hljs-keyword" style="color:#0000FF;">true</span>);
          p.setJdbcInterceptors( <span class="hljs-string" style="color:#A31515;">"org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;"</span>+ <span class="hljs-string" style="color:#A31515;">"org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer"</span>);
          DataSource datasource = <span class="hljs-keyword" style="color:#0000FF;">new</span> DataSource();
          datasource.setPoolProperties(p);

          Connection con = <span class="hljs-keyword" style="color:#0000FF;">null</span>; <span class="hljs-keyword" style="color:#0000FF;">try</span> {
            con = datasource.getConnection();
            Statement st = con.createStatement();
            ResultSet rs = st.executeQuery(<span class="hljs-string" style="color:#A31515;">"select * from user"</span>); <span class="hljs-keyword" style="color:#0000FF;">int</span> cnt = <span class="hljs-number">1</span>; <span class="hljs-keyword" style="color:#0000FF;">while</span> (rs.next()) {
                System.out.println((cnt++)+<span class="hljs-string" style="color:#A31515;">". Host:"</span> +rs.getString(<span class="hljs-string" style="color:#A31515;">"Host"</span>)+ <span class="hljs-string" style="color:#A31515;">" User:"</span>+rs.getString(<span class="hljs-string" style="color:#A31515;">"User"</span>)+<span class="hljs-string" style="color:#A31515;">" Password:"</span>+rs.getString(<span class="hljs-string" style="color:#A31515;">"Password"</span>));
            }
            rs.close();
            st.close();
          } <span class="hljs-keyword" style="color:#0000FF;">finally</span> { <span class="hljs-keyword" style="color:#0000FF;">if</span> (con!=<span class="hljs-keyword" style="color:#0000FF;">null</span>) <span class="hljs-keyword" style="color:#0000FF;">try</span> {con.close();}<span class="hljs-keyword" style="color:#0000FF;">catch</span> (Exception ignore) {}
          }
      }

  }</pre>
<h3 style="font-size:16px;font-family:&quot;">
	作为资源使用
</h3>
<p style="font-family:&quot;font-size:14px;">
	下例展示了如何为 JNDI 查找配置资源。
</p>
<pre>&lt;Resource name=<span class="hljs-string" style="color:#A31515;">"jdbc/TestDB"</span> auth=<span class="hljs-string" style="color:#A31515;">"Container"</span> <span class="hljs-class"><span class="hljs-keyword" style="color:#0000FF;">type</span></span>=<span class="hljs-string" style="color:#A31515;">"javax.sql.DataSource"</span> factory=<span class="hljs-string" style="color:#A31515;">"org.apache.tomcat.jdbc.pool.DataSourceFactory"</span> testWhileIdle=<span class="hljs-string" style="color:#A31515;">"true"</span> testOnBorrow=<span class="hljs-string" style="color:#A31515;">"true"</span> testOnReturn=<span class="hljs-string" style="color:#A31515;">"false"</span> validationQuery=<span class="hljs-string" style="color:#A31515;">"SELECT 1"</span> validationInterval=<span class="hljs-string" style="color:#A31515;">"30000"</span> timeBetweenEvictionRunsMillis=<span class="hljs-string" style="color:#A31515;">"30000"</span> maxActive=<span class="hljs-string" style="color:#A31515;">"100"</span> minIdle=<span class="hljs-string" style="color:#A31515;">"10"</span> maxWait=<span class="hljs-string" style="color:#A31515;">"10000"</span> initialSize=<span class="hljs-string" style="color:#A31515;">"10"</span> removeAbandonedTimeout=<span class="hljs-string" style="color:#A31515;">"60"</span> removeAbandoned=<span class="hljs-string" style="color:#A31515;">"true"</span> logAbandoned=<span class="hljs-string" style="color:#A31515;">"true"</span> minEvictableIdleTimeMillis=<span class="hljs-string" style="color:#A31515;">"30000"</span> jmxEnabled=<span class="hljs-string" style="color:#A31515;">"true"</span> jdbcInterceptors=<span class="hljs-string" style="color:#A31515;">"org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;
            org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer"</span> username=<span class="hljs-string" style="color:#A31515;">"root"</span> password=<span class="hljs-string" style="color:#A31515;">"password"</span> driverClassName=<span class="hljs-string" style="color:#A31515;">"com.mysql.jdbc.Driver"</span> url=<span class="hljs-string" style="color:#A31515;">"jdbc:mysql://localhost:3306/mysql"</span>/&gt;</pre>
<h3 style="font-size:16px;font-family:&quot;">
	异步连接获取
</h3>
<p style="font-family:&quot;font-size:14px;">
	Tomcat JDBC 连接池支持异步连接获取，无需为池库添加任何额外线程。这是通过在数据源上添加一个方法&nbsp;Future&lt;Connection&gt; getConnectionAsync()&nbsp;来实现的。为了使用异步获取，必须满足两个条件：
</p>
<ol style="font-family:&quot;font-size:14px;">
	<li>
		必须把&nbsp;failQueue&nbsp;属性设为&nbsp;true。
	</li>
	<li>
		必须把数据源转换为&nbsp;org.apache.tomcat.jdbc.pool.DataSource。
	</li>
</ol>
<p style="font-family:&quot;font-size:14px;">
	下例就使用了异步获取功能：
</p>
<pre>Connection con = null; <span class="hljs-keyword" style="color:#0000FF;">try</span> {
    Future&lt;Connection&gt; <span class="hljs-built_in" style="color:#0000FF;">future</span> = datasource.getConnectionAsync(); <span class="hljs-keyword" style="color:#0000FF;">while</span> (!<span class="hljs-built_in" style="color:#0000FF;">future</span>.isDone()) {
      System.out.println(<span class="hljs-string" style="color:#A31515;">"Connection is not yet available. Do some background work"</span>); <span class="hljs-keyword" style="color:#0000FF;">try</span> {
        Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment" style="color:#008000;">//simulate work</span> }<span class="hljs-keyword" style="color:#0000FF;">catch</span> (InterruptedException x) {
        Thread.currentThread().interrupt();
      }
    }
    con = <span class="hljs-built_in" style="color:#0000FF;">future</span>.get(); <span class="hljs-comment" style="color:#008000;">//should return instantly</span> Statement st = con.createStatement();
    ResultSet rs = st.executeQuery(<span class="hljs-string" style="color:#A31515;">"select * from user"</span>);</pre>
<h3 style="font-size:16px;font-family:&quot;">
	拦截器
</h3>
<p style="font-family:&quot;font-size:14px;">
	对于启用、禁止或修改特定连接或其组件的功能而言，使用拦截器无疑是一种非常强大的方式。There are many different use cases for when interceptors are useful。默认情况下，基于性能方面的考虑，连接池是无状态的。连接池本身所插入的状态是&nbsp;defaultAutoCommit、defaultReadOnly、defaultTransactionIsolation，或&nbsp;defaultCatalog（如果设置了这些状态）。这 4 个状态只有在连接创建时才设置。无论这些属性是否在连接使用期间被修改，池本身都不能重置它们。
</p>
<p style="font-family:&quot;font-size:14px;">
	拦截器必须扩展自&nbsp;org.apache.tomcat.jdbc.pool.JdbcInterceptor&nbsp;类。该类相当简单，你必须利用一个无参数构造函数。
</p>
<pre><span class="hljs-function"><span class="hljs-keyword" style="color:#0000FF;">public</span> <span class="hljs-title" style="color:#A31515;">JdbcInterceptor</span>(<span class="hljs-params"></span>)</span> {
  }</pre>
<p style="font-family:&quot;font-size:14px;">
	当从连接池借出一个连接时，拦截器能够通过实现以下方法，初始化这一事件或以一些其他形式来响应该事件。
</p>
<p style="font-family:&quot;font-size:14px;">
	public abstract void reset(ConnectionPool parent, PooledConnection con);
</p>
<p style="font-family:&quot;font-size:14px;">
	上面这个方法有两个参数，一个是连接池本身的引用&nbsp;ConnectionPool parent，一个是底层连接的引用&nbsp;PooledConnection con。
</p>
<p style="font-family:&quot;font-size:14px;">
	当调用&nbsp;java.sql.Connection&nbsp;对象上的方法时，会导致以下方法被调用：
</p>
<p style="font-family:&quot;font-size:14px;">
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
</p>
<p style="font-family:&quot;font-size:14px;">
	Method method&nbsp;是被调用的实际方法，Object[] args&nbsp;是参数。通过观察下面这个非常简单的例子，我们可以解释如果当连接已经关闭时，如何让&nbsp;java.sql.Connection.close()&nbsp;的调用变得无用。
</p>
<pre><span class="hljs-keyword" style="color:#0000FF;">if</span> (CLOSE_VAL==method.getName()) { <span class="hljs-keyword" style="color:#0000FF;">if</span> (isClosed()) <span class="hljs-keyword" style="color:#0000FF;">return</span> <span class="hljs-literal" style="color:#A31515;">null</span>; <span class="hljs-comment" style="color:#008000;">//noop for already closed.</span> } <span class="hljs-keyword" style="color:#0000FF;">return</span> <span class="hljs-keyword" style="color:#0000FF;">super</span>.invoke(proxy,method,args);</pre>
<h4 style="font-size:14px;color:#333333;font-family:&quot;">
	池启动与停止
</h4>
<p style="font-family:&quot;font-size:14px;">
	当连接池开启或关闭时，你可以得到相关通知。可能每个拦截器类只通知一次，即使它是一个实例方法。也可能使用当前未连接到池中的拦截器来通知你。
</p>
<pre><span class="hljs-function"><span class="hljs-keyword" style="color:#0000FF;">public</span> <span class="hljs-keyword" style="color:#0000FF;">void</span> <span class="hljs-title" style="color:#A31515;">poolStarted</span>(<span class="hljs-params">ConnectionPool pool</span>)</span> {
  } <span class="hljs-function"><span class="hljs-keyword" style="color:#0000FF;">public</span> <span class="hljs-keyword" style="color:#0000FF;">void</span> <span class="hljs-title" style="color:#A31515;">poolClosed</span>(<span class="hljs-params">ConnectionPool pool</span>)</span> {
  }</pre>
<p style="font-family:&quot;font-size:14px;">
	当重写这些方法时，如果你扩展自&nbsp;JdbcInterceptor&nbsp;之外的类，不要忘记调用超类。
</p>
<h4 style="font-size:14px;color:#333333;font-family:&quot;">
	配置拦截器
</h4>
<p style="font-family:&quot;font-size:14px;">
	拦截器可以通过&nbsp;jdbcInterceptors&nbsp;属性或&nbsp;setJdbcInterceptors&nbsp;方法来配置。拦截器也可以有属性，可以通过如下方式来配置：
</p>
<pre><span class="hljs-built_in" style="color:#0000FF;">String</span> jdbcInterceptors= <span class="hljs-string" style="color:#A31515;">"org.apache.tomcat.jdbc.pool.interceptor.ConnectionState(useEquals=true,fast=yes)"</span> </pre>
<h4 style="font-size:14px;color:#333333;font-family:&quot;">
	拦截器属性
</h4>
<p style="font-family:&quot;font-size:14px;">
	既然拦截器也有属性，那么你也可以读取其中的属性值。你可以重写&nbsp;setProperties&nbsp;方法。
</p>
<pre><span class="hljs-keyword" style="color:#0000FF;">public</span> <span class="hljs-built_in" style="color:#0000FF;">void</span> <span class="hljs-function"><span class="hljs-title" style="color:#A31515;">setProperties</span>(<span class="hljs-params"><span class="hljs-built_in" style="color:#0000FF;">Map</span>&lt;<span class="hljs-built_in" style="color:#0000FF;">String</span>, InterceptorProperty&gt; properties</span>)</span> { <span class="hljs-built_in" style="color:#0000FF;">super</span>.setProperties(properties);
     final <span class="hljs-built_in" style="color:#0000FF;">String</span> myprop = <span class="hljs-string" style="color:#A31515;">"myprop"</span>;
     InterceptorProperty p1 = properties.get(myprop); <span class="hljs-keyword" style="color:#0000FF;">if</span> (p1!=<span class="hljs-literal" style="color:#A31515;">null</span>) {
         setMyprop(Long.parseLong(p1.getValue()));
     }
  }</pre>
<h3 style="font-size:16px;font-family:&quot;">
	获取实际的 JDBC 连接
</h3>
<p style="font-family:&quot;font-size:14px;">
	连接池围绕实际的连接创建包装器，为的是能够正确地池化。同样，为了执行特定的功能，我们也可以在这些包装器中创建拦截器。如果不需要获取实际的连接，可以使用&nbsp;javax.sql.PooledConnection&nbsp;接口。
</p>
<pre><span class="hljs-attribute" style="color:#A31515;">Connection</span> con = datasource.getConnection(); <span class="hljs-attribute" style="color:#A31515;">Connection</span> actual = ((javax.sql.PooledConnection)con).getConnection();</pre>
<h2 id="fcba60e7730df08c8f9904b9437f4c0e" style="font-size:21px;font-family:&quot;">
	构建
</h2>
<p style="font-family:&quot;font-size:14px;">
	下面利用 1.6 来构建 JDBC 连接池代码，但它也可以向后兼容到 1.5 运行时环境。为了单元测试，使用 1.6 或更高版本。
</p>
<p style="font-family:&quot;font-size:14px;">
	更多的关于 JDBC 用途的 Tomcat 配置范例可参看 [Tomcat 文档]()。
</p>
<h3 style="font-size:16px;font-family:&quot;">
	从源代码构建
</h3>
<p style="font-family:&quot;font-size:14px;">
	构建非常简单。池依赖于&nbsp;tomcat-juli.jar，在这种情况下，需要&nbsp;SlowQueryReportJmx。
</p>
<pre><span class="hljs-attr" style="color:#FF0000;">javac</span> <span class="hljs-string" style="color:#A31515;">-classpath tomcat-juli.jar \
        -d . \
        org/apache/tomcat/jdbc/pool/*.java \
        org/apache/tomcat/jdbc/pool/interceptor/*.java \
        org/apache/tomcat/jdbc/pool/jmx/*.java</span> </pre>
<p style="font-family:&quot;font-size:14px;">
	构建文件位于 Tomcat 的<a href="http://svn.apache.org/viewvc/tomcat/trunk/modules/jdbc-pool/">源代码仓库</a>中。
</p>
<p style="font-family:&quot;font-size:14px;">
	为了方便起见，在通过简单构建命令生成所需文件的地方也包含了一个构建文件。
</p>
<pre>ant download  (<span class="hljs-name" style="color:#0000FF;">downloads</span> dependencies)
  ant build     (<span class="hljs-name" style="color:#0000FF;">compiles</span> and generates .jar files)
  ant dist      (<span class="hljs-name" style="color:#0000FF;">creates</span> a release package)
  ant test      (<span class="hljs-name" style="color:#0000FF;">runs</span> tests, expects a test database to be setup)</pre>
<p style="font-family:&quot;font-size:14px;">
	系统针对 Maven 构建进行组织，但是没有生成发布组件，只有库本身。
</p></div>
      <!-- 
      <p class="diggit">
        <a href="JavaScript:makeRequest('/e/public/digg/?classid=3&amp;id=19&amp;dotop=1&amp;doajax=1&amp;ajaxarea=diggnum','EchoReturnedText','GET','');"> 很赞哦！ </a>(<b id="diggnum"><script type="text/javascript" src="/e/public/ViewClick/?classid=2&amp;id=20&amp;down=5"></script>13</b>)
      </p>
       -->

    </div>
    
    <div class="nextinfo">
      
        
        
            <p>上一篇：<a href="/p/2089.html">spring boot插件开发实战和原理</a></p>
        
        
      
      
        
        
            <p>下一篇：<a href="/p/2091.html">负载均衡--LVS负载均衡（LVS简介、三种工作模式、十种调度算法）</a></p>
        
      
    </div>
    
    <!-- 转载声明 -->
    
        <div style="padding-left:20px;">本文转自：<a href="https://www.cnblogs.com/pingxin/p/p00063.html" target="_blank">https://www.cnblogs.com/pingxin/p/p00063.html</a></div>
    
	
	<div><!-- 添加新的评论 -->
		
   
		
		<div class="news_pl">
		    	
		  	
		</div>
	
	</div>

 
 		
	</div>

</div>

<div class="blank"></div>

	<div  style="position: fixed;display: float;top: 2px;right: 2px;width: 200px;"><!-- 评论部分 -->

		<!---->
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
			<div>
				<span style="display:block;margin:10px;"><a style="text-decoration:none;color:#5BC648;" href="#"></a></span><!-- 标题列表，快速查看-->
			</div>
		
		
	
		
		
	</div>

	<link href="/extends/kindeditor-4.1.10/plugins/code/prettify.css" rel="stylesheet" type="text/css"></script>
	<script charset="utf-8" src="/extends/kindeditor-4.1.10/plugins/code/prettify.js"></script>
	<script type="text/javascript">
	prettyPrint();
	</script>

<!-- 显示访问记录 -->

	<footer>
		<!-- 底部居中的 -->
		<p>Copyright © <a href="http://comonly.cn/" target="_blank">comonly.cn</a> </p>
		<p>备案号：<a href="http://www.miitbeian.gov.cn/">鄂ICP备16003690号-3</a></p>
		<div class="cnzz_bot">
			<style>
			.cnzz_bot img{
			    margin:0 auto;
			}
			</style>
			<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277884732'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1277884732%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
		</div>
	</footer>

 
</body>
</html>
